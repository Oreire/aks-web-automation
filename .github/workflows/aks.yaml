# name: Deploy App to AKS

# on:
#   push:
#     branches:
#       - main
#   workflow_dispatch:

# env:
#   IMAGE_NAME: docker.io/webaz
#   IMAGE_TAG: latest
#   RESOURCE_GROUP: aks-resource-group   
#   AKS_CLUSTER_NAME: aks-cluster       
#   NAMESPACE: default

# jobs:
#   deploy:
#     runs-on: ubuntu-latest
#     defaults:
#       run:
#         shell: bash

#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       # Azure login
#       - name: Azure Login
#         uses: azure/login@v1
#         with:
#           creds: ${{ secrets.AZURE_CREDENTIALS }}
#           enable-AzPSSession: false
#           environment: AzureCloud

#       # Get AKS credentials
#       - name: Get AKS Credentials
#         run: |
#           az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_CLUSTER_NAME --overwrite-existing

#       # Wait for AKS nodes to be ready
#       - name: Wait for AKS Nodes Ready
#         run: |
#           echo "Waiting for AKS nodes to be ready..."
#           for i in {1..30}; do
#             READY_NODES=$(kubectl get nodes --no-headers 2>/dev/null | grep -c ' Ready')
#             TOTAL_NODES=$(kubectl get nodes --no-headers 2>/dev/null | wc -l)
#             if [ "$TOTAL_NODES" -gt 0 ] && [ "$READY_NODES" -eq "$TOTAL_NODES" ]; then
#               echo "All $READY_NODES AKS nodes are ready!"
#               break
#             fi
#             echo "Nodes not ready yet. Waiting 20s..."
#             sleep 20
#           done

#       # Deploy to Kubernetes
#       - name: Deploy Kubernetes Manifests
#         run: |
#           echo "Deploying Kubernetes manifests..."
#           kubectl apply -f AKS/ || kubectl replace --force -f AKS/

#       # Wait for LoadBalancer IP
#       - name: Wait for LoadBalancer IP
#         id: get-lb-ip
#         run: |
#           echo "Waiting for LoadBalancer IP..."
#           for i in {1..30}; do
#             IP=$(kubectl get svc lanik-lb-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
#             if [ -n "$IP" ]; then
#               echo "LoadBalancer IP is: $IP"
#               echo "LB_IP=$IP" >> $GITHUB_ENV
#               echo "::set-output name=lb_ip::$IP"
#               break
#             fi
#             sleep 10
#           done

#       # Print LoadBalancer IP in job summary
#       - name: Show LoadBalancer IP
#         run: |
#           echo "✅ Application is accessible at http://$LB_IP"

name: Provision and Deploy App to AKS

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  IMAGE_NAME: docker.io/webaz
  IMAGE_TAG: latest
  RESOURCE_GROUP: aks-resource-group
  AKS_CLUSTER_NAME: aks-cluster
  NAMESPACE: default

jobs:
  # -----------------------------------------------------
  # 1️⃣ PROVISION AKS CLUSTER USING TERRAFORM
  # -----------------------------------------------------
  provision:
    name: Provision AKS with Terraform
    runs-on: ubuntu-latest

    defaults:
      run:
        shell: bash

    outputs:
      rg_name: ${{ steps.aks.outputs.rg_name }}
      aks_name: ${{ steps.aks.outputs.aks_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Create backend.tfvars
        run: |
         echo 'resource_group_name  = "aks-resource-group"' > INFRA/backend.tfvars
         echo 'storage_account_name = "k8scloudtfstateuks"' >> INFRA/backend.tfvars
         echo 'container_name       = "tfstate"' >> INFRA/backend.tfvars
         echo 'key                  = "terraform.tfstate"' >> INFRA/backend.tfvars
         echo 'access_key           = "${{ secrets.AZURE_STORAGE_KEY }}"' >> INFRA/backend.tfvars


      - name: Terraform Init
        working-directory: ./INFRA
        env:
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        run: terraform init -backend-config="backend.tfvars"
      
      # - name: Terraform Import Resource Group
      #   working-directory: ./INFRA
      #   env:
      #     ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
      #     ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
      #     ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
      #     ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
      #   run: terraform import azurerm_resource_group.aks_rg /subscriptions/${{ env.ARM_SUBSCRIPTION_ID }}/resourceGroups/aks-resource-group

      - name: Terraform Plan
        working-directory: ./INFRA
        env:
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: ./INFRA
        env:
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        run: terraform apply -auto-approve tfplan

      - name: Get AKS Cluster Info
        id: aks
        working-directory: ./INFRA
        run: |
          AKS_NAME=$(terraform output -raw aks_name)
          RG_NAME=$(terraform output -raw resource_group_name)
          echo "AKS_NAME=$AKS_NAME" >> $GITHUB_ENV
          echo "RG_NAME=$RG_NAME" >> $GITHUB_ENV
          echo "aks_name=$AKS_NAME" >> $GITHUB_OUTPUT
          echo "rg_name=$RG_NAME" >> $GITHUB_OUTPUT

  # -----------------------------------------------------
  # 2️⃣ DEPLOY APP TO THE PROVISIONED AKS CLUSTER
  # -----------------------------------------------------
  deploy:
    name: Deploy Application to AKS
    runs-on: ubuntu-latest
    needs: provision

    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: false
          environment: AzureCloud

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.provision.outputs.rg_name }} \
            --name ${{ needs.provision.outputs.aks_name }} \
            --overwrite-existing

      - name: Wait for AKS Nodes Ready
        run: |
          echo "Waiting for AKS nodes to be ready..."
          for i in {1..30}; do
            READY_NODES=$(kubectl get nodes --no-headers 2>/dev/null | grep -c ' Ready')
            TOTAL_NODES=$(kubectl get nodes --no-headers 2>/dev/null | wc -l)
            if [ "$TOTAL_NODES" -gt 0 ] && [ "$READY_NODES" -eq "$TOTAL_NODES" ]; then
              echo "All $READY_NODES AKS nodes are ready!"
              break
            fi
            echo "Nodes not ready yet. Waiting 20s..."
            sleep 20
          done

      - name: Deploy Kubernetes Manifests
        run: |
          echo "Deploying Kubernetes manifests..."
          kubectl apply -f AKS/ || kubectl replace --force -f AKS/

      - name: Wait for LoadBalancer IP
        id: get-lb-ip
        run: |
          echo "Waiting for LoadBalancer IP..."
          for i in {1..30}; do
            IP=$(kubectl get svc lanik-lb-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$IP" ]; then
              echo "LoadBalancer IP is: $IP"
              echo "LB_IP=$IP" >> $GITHUB_ENV
              echo "::set-output name=lb_ip::$IP"
              break
            fi
            sleep 10
          done

      - name: Show LoadBalancer IP
        run: |
          echo "✅ Application is accessible at http://$LB_IP"


