name: Provision and Deploy App to AKS

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  IMAGE_NAME: docker.io/webaz
  IMAGE_TAG: latest
  NAMESPACE: default

jobs:
  # -----------------------------------------------------
  # 1ï¸âƒ£ PROVISION AKS CLUSTER USING TERRAFORM
  # -----------------------------------------------------
  provision:
    name: Provision AKS with Terraform
    runs-on: ubuntu-latest

    defaults:
      run:
        shell: bash

    outputs:
      rg_name: ${{ steps.aks.outputs.rg_name }}
      aks_name: ${{ steps.aks.outputs.aks_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      # Optional backend file creation (only if your backend expects these)
      - name: Create backend.tfvars
        run: |
          echo 'resource_group_name  = "aks-resource-group"' > INFRA/backend.tfvars
          echo 'storage_account_name = "k8scloudtfstateuks"' >> INFRA/backend.tfvars
          echo 'container_name       = "tfstate"' >> INFRA/backend.tfvars
          echo 'key                  = "terraform.tfstate"' >> INFRA/backend.tfvars
          echo 'access_key           = "${{ secrets.AZURE_STORAGE_KEY }}"' >> INFRA/backend.tfvars

      # Initialize Terraform (backend config is optional)
      - name: Terraform Init
        working-directory: ./INFRA
        env:
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        run: |
          if [ -f "backend.tfvars" ]; then
            terraform init -backend-config="backend.tfvars"
          else
            terraform init
          fi

      - name: Terraform Plan
        working-directory: ./INFRA
        env:
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: ./INFRA
        env:
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        run: terraform apply -auto-approve tfplan

      # âœ… Fixed Output Capture (filter ::debug:: lines)
      - name: Get AKS Cluster Info
        id: aks
        working-directory: ./INFRA
        run: |
          AKS_NAME=$(terraform output -raw aks_name 2>/dev/null | grep -v "::" || echo "")
          RG_NAME=$(terraform output -raw resource_group_name 2>/dev/null | grep -v "::" || echo "")

          echo "AKS_NAME=${AKS_NAME}" >> $GITHUB_ENV
          echo "RG_NAME=${RG_NAME}" >> $GITHUB_ENV

          echo "aks_name=${AKS_NAME}" >> $GITHUB_OUTPUT
          echo "rg_name=${RG_NAME}" >> $GITHUB_OUTPUT

          echo "âœ… AKS Cluster Name: ${AKS_NAME}"
          echo "âœ… Resource Group: ${RG_NAME}"

  # -----------------------------------------------------
  # 2ï¸âƒ£ DEPLOY APP TO THE PROVISIONED AKS CLUSTER
  # -----------------------------------------------------
  deploy:
    name: Deploy Application to AKS
    runs-on: ubuntu-latest
    needs: provision

    defaults:
      run:
        shell: bash

    steps:
      # --- Checkout code ---
      - name: Checkout code
        uses: actions/checkout@v3

      # --- Azure authentication ---
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: false
          environment: AzureCloud

      # --- Ensure Azure CLI is at a stable version (Quick Fix) ---
      - name: Install stable Azure CLI
        run: |
          echo "ðŸ”§ Ensuring stable Azure CLI version..."
          sudo apt-get update -y
          sudo apt-get install -y azure-cli
          az version

      # --- Retrieve AKS credentials safely ---
      - name: Get AKS Credentials
        run: |
          echo "Retrieving AKS credentials..."
          RG_NAME="${{ needs.provision.outputs.rg_name }}"
          AKS_NAME="${{ needs.provision.outputs.aks_name }}"

          echo "Using Resource Group: $RG_NAME"
          echo "Using AKS Cluster: $AKS_NAME"

          az aks get-credentials \
            --resource-group "$RG_NAME" \
            --name "$AKS_NAME" \
            --overwrite-existing \
            --only-show-errors

      # --- Wait for AKS Nodes Ready ---
      - name: Wait for AKS Nodes Ready
        run: |
          echo "Waiting for AKS nodes to be ready..."
          for i in {1..30}; do
            READY_NODES=$(kubectl get nodes --no-headers 2>/dev/null | grep -c ' Ready')
            TOTAL_NODES=$(kubectl get nodes --no-headers 2>/dev/null | wc -l)
            if [ "$TOTAL_NODES" -gt 0 ] && [ "$READY_NODES" -eq "$TOTAL_NODES" ]; then
              echo "âœ… All $READY_NODES AKS nodes are ready!"
              break
            fi
            echo "Nodes not ready yet. Waiting 20s..."
            sleep 20
          done

      # --- Deploy Kubernetes Manifests ---
      - name: Deploy Kubernetes Manifests
        run: |
          echo "ðŸš€ Deploying Kubernetes manifests..."
          kubectl apply -f AKS/ || kubectl replace --force -f AKS/

      # --- Wait for LoadBalancer IP ---
      - name: Wait for LoadBalancer IP
        id: get-lb-ip
        run: |
          echo "Waiting for LoadBalancer IP..."
          for i in {1..30}; do
            IP=$(kubectl get svc lanik-lb-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
            if [ -n "$IP" ]; then
              echo "LoadBalancer IP is: $IP"
              echo "LB_IP=$IP" >> $GITHUB_ENV
              echo "lb_ip=$IP" >> $GITHUB_OUTPUT
              break
            fi
            echo "Still waiting for LoadBalancer IP... (Attempt $i)"
            sleep 10
          done

      # --- Display LoadBalancer IP ---
      - name: Show LoadBalancer IP
        run: |
          echo "âœ… Application is accessible at: http://$LB_IP"

