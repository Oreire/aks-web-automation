name: Provision and Deploy App to AKS

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  IMAGE_NAME: docker.io/webaz
  IMAGE_TAG: latest
  NAMESPACE: default

jobs:
  # -----------------------------------------------------
  # 1ï¸âƒ£ PROVISION AKS CLUSTER USING TERRAFORM
  # -----------------------------------------------------
  provision:
    name: Provision AKS with Terraform
    runs-on: ubuntu-latest

    defaults:
      run:
        shell: bash

    outputs:
      rg_name: ${{ steps.aks.outputs.rg_name }}
      aks_name: ${{ steps.aks.outputs.aks_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Create backend.tfvars
        run: |
          echo 'resource_group_name  = "aks-resource-group"' > INFRA/backend.tfvars
          echo 'storage_account_name = "k8scloudtfstateuks"' >> INFRA/backend.tfvars
          echo 'container_name       = "tfstate"' >> INFRA/backend.tfvars
          echo 'key                  = "terraform.tfstate"' >> INFRA/backend.tfvars
          echo 'access_key           = "${{ secrets.AZURE_STORAGE_KEY }}"' >> INFRA/backend.tfvars

      - name: Terraform Init
        working-directory: ./INFRA
        env:
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        run: terraform init -backend-config="backend.tfvars"

      # Auto-Import Step: prevent RG already-exists failure
      - name: Auto-import existing Resource Group if present
        working-directory: ./INFRA
        env:
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        run: |
          echo "ğŸ©µ Checking if resource group exists..."
          if az group show --name aks-resource-group --subscription $ARM_SUBSCRIPTION_ID >/dev/null 2>&1; then
            echo "â„¹ï¸ Resource group already exists. Importing into Terraform state..."
            terraform import -no-color azurerm_resource_group.aks_rg \
              "/subscriptions/${ARM_SUBSCRIPTION_ID}/resourceGroups/aks-resource-group" || true
          else
            echo "âœ… Resource group does not exist. Terraform will create it."
          fi

      - name: Terraform Plan
        working-directory: ./INFRA
        env:
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: ./INFRA
        env:
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        run: terraform apply -auto-approve tfplan

      - name: Get AKS Cluster Info
        id: aks
        working-directory: ./INFRA
        run: |
          AKS_NAME=$(terraform output -raw aks_name 2>/dev/null | grep -v "::" || echo "")
          RG_NAME=$(terraform output -raw resource_group_name 2>/dev/null | grep -v "::" || echo "")
          echo "AKS_NAME=${AKS_NAME}" >> $GITHUB_ENV
          echo "RG_NAME=${RG_NAME}" >> $GITHUB_ENV
          echo "aks_name=${AKS_NAME}" >> $GITHUB_OUTPUT
          echo "rg_name=${RG_NAME}" >> $GITHUB_OUTPUT
          echo "âœ… AKS Cluster Name: ${AKS_NAME}"
          echo "âœ… Resource Group: ${RG_NAME}"

  # -----------------------------------------------------
  # 2ï¸âƒ£ DEPLOY APP TO THE PROVISIONED AKS CLUSTER
  # -----------------------------------------------------
  deploy:
    name: Deploy Application to AKS
    runs-on: ubuntu-latest
    needs: provision

    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install Stable Azure CLI (v2.64.0)
        run: |
          sudo rm -f /etc/apt/sources.list.d/azure-cli.list /etc/apt/sources.list.d/azure-cli.sources || true
          sudo apt-get update -y
          sudo apt-get install -y ca-certificates curl apt-transport-https lsb-release gnupg
          curl -sL https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/microsoft.gpg > /dev/null
          echo "deb [arch=amd64] https://packages.microsoft.com/repos/azure-cli/ $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/azure-cli.list
          sudo apt-get update -y
          sudo apt-get install -y --allow-downgrades azure-cli=2.64.0-1~$(lsb_release -cs)

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: false
          environment: AzureCloud

      - name: ğŸ§° Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5
      
      - name: ğŸª£ Initialize Terraform backend
        run: |
          cd INFRA
          terraform init -reconfigure \
            -backend-config="resource_group_name=aks-resource-group" \
            -backend-config="storage_account_name=k8scloudtfstateuks" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=infra.tfstate"
        env:
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}

      - name: ğŸ“¦ Fetch AKS output values from Terraform
        working-directory: ./INFRA
        run: |
          terraform init -reconfigure -input=false \
            -backend-config="resource_group_name=aks-resource-group" \
            -backend-config="storage_account_name=k8scloudtfstateuks" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=infra.tfstate"
          RG_NAME=$(terraform output -raw resource_group_name || echo "unknown-rg")
          AKS_NAME=$(terraform output -raw aks_name || echo "unknown-aks")
          echo "RG_NAME=${RG_NAME}" >> $GITHUB_ENV
          echo "AKS_NAME=${AKS_NAME}" >> $GITHUB_ENV
          echo "rg_name=${RG_NAME}" >> $GITHUB_OUTPUT
          echo "aks_name=${AKS_NAME}" >> $GITHUB_OUTPUT
          echo "Using Resource Group: ${RG_NAME}"
          echo "Using AKS Cluster: ${AKS_NAME}"
        env:
          ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
          ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
          ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
          ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group "$RG_NAME" \
            --name "$AKS_NAME" \
            --overwrite-existing \
            --only-show-errors

      - name: Wait for AKS Nodes Ready
        run: |
          for i in {1..30}; do
            READY_NODES=$(kubectl get nodes --no-headers 2>/dev/null | grep -c ' Ready' || true)
            TOTAL_NODES=$(kubectl get nodes --no-headers 2>/dev/null | wc -l || true)
            if [ "$TOTAL_NODES" -gt 0 ] && [ "$READY_NODES" -eq "$TOTAL_NODES" ]; then
              echo "âœ… All $READY_NODES AKS nodes are ready!"
              break
            fi
            echo "Nodes not ready yet. Waiting 20s..."
            sleep 20
          done

      - name: Deploy Kubernetes Manifests
        run: |
          kubectl apply -f AKS/ || kubectl replace --force -f AKS/

      - name: Wait for LoadBalancer IP
        id: get-lb-ip
        run: |
          for i in {1..30}; do
            IP=$(kubectl get svc lanik-lb-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
            if [ -n "$IP" ]; then
              echo "LoadBalancer IP is: $IP"
              echo "LB_IP=$IP" >> $GITHUB_ENV
              echo "lb_ip=$IP" >> $GITHUB_OUTPUT
              break
            fi
            echo "Still waiting for LoadBalancer IP... (Attempt $i)"
            sleep 10
          done

      - name: Show LoadBalancer IP
        run: |
          echo "âœ… Application is accessible at: http://$LB_IP"

      # ğŸ” Verify LoadBalancer Connectivity
      - name: ğŸ” Verify LoadBalancer Connectivity
        run: |
          echo "ğŸ” Verifying LoadBalancer connectivity..."

          if [ -z "$LB_IP" ]; then
            echo "âŒ No LoadBalancer IP detected. Exiting."
            kubectl get svc -A
            exit 1
          fi

          echo "ğŸŒ Checking access to http://$LB_IP ..."
          for i in {1..10}; do
            if curl -s --max-time 10 "http://$LB_IP" > /dev/null; then
              echo "âœ… Successfully connected to LoadBalancer at $LB_IP"
              exit 0
            else
              echo "âš ï¸ Attempt $i: Still unable to reach LoadBalancer..."
              sleep 10
            fi
          done

          echo "âŒ Could not reach LoadBalancer service after 10 attempts."
          echo "ğŸ§  Dumping Kubernetes diagnostics for investigation..."

          echo "--- Services ---"
          kubectl get svc -o wide

          echo "--- Pods ---"
          kubectl get pods -o wide

          echo "--- Endpoints ---"
          kubectl get endpoints

          echo "--- Events ---"
          kubectl get events --sort-by=.metadata.creationTimestamp | tail -n 20

          exit 1

      # âœ… Deployment Summary
      - name: âœ… Deployment Summary
        if: success()
        run: |
          echo "ğŸš€ Application successfully deployed and reachable!"
          echo "ğŸŒ Visit: http://$LB_IP"

    
      - name: ğŸ§­ Install ArgoCD in AKS
        run: |
          echo "ğŸš€ Installing ArgoCD..."
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          echo "â³ Waiting for ArgoCD server to be ready..."
          kubectl rollout status deployment/argocd-server -n argocd --timeout=300s

      - name: âš™ï¸ Apply ArgoCD Project and Application
        run: |
          echo "ğŸ“ Applying ArgoCD manifests..."
          kubectl apply -f ./ArgoCD/project.yaml
          kubectl apply -f ./ArgoCD/argocd-app.yaml
          kubectl apply -f ./ArgoCD/monitoring-app.yaml -n argocd
          echo "âœ… ArgoCD configuration applied successfully."

      # -------------------------------
      # ğŸ“Š Install Prometheus & Grafana (Optional)
      # -------------------------------
      - name: ğŸ“ˆ Install Monitoring Stack
        run: |
          kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          helm upgrade --install kube-prom prometheus-community/kube-prometheus-stack -n monitoring

      - name: ğŸ“ˆ Apply Monitoring Resources
        run: kubectl apply -k ./MONITORING/
    